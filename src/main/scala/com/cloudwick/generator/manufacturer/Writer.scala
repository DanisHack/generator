package com.cloudwick.generator.manufacturer

import java.io.File
import java.util.concurrent.atomic.AtomicLong

import com.cloudwick.generator.utils.{FileHandler, Utils, LazyLogging}

import scala.collection.mutable.ArrayBuffer

/**
 * Writes events to file
 * @author ashrith
 */
class Writer(eventsStartRange: Int,
  eventsEndRange: Int,
  counter: AtomicLong,
  sizeCounter: AtomicLong,
  config: OptionsConfig) extends Runnable with LazyLogging {
  lazy val utils = new Utils

  lazy val sleepTime = if(config.eventsPerSec == 0) 0 else 1000/config.eventsPerSec

  def threadName = Thread.currentThread().getName

  def formatEventToString(event: ManufacturerEvent, formatter: String) = {
    val formatChar = formatter match {
      case "tsv" => '\t'
      case "csv" => ','
      case _ => '\t'
    }
    "%s%c%s%c%s%c%s%c%s%c%s%c%s\n".format(event.manufacturerName, formatChar, event
      .manufacturerPartNumber,
      formatChar, event.category, formatChar, event.recordType, formatChar, event.recordTypeKey,
      formatChar, event.entityType, formatChar, event.genericNumber)
  }

  def run() = {
    val totalEvents = eventsEndRange - eventsStartRange + 1
    var batchCount: Int = 0
    var outputFileHandler: FileHandler = null
    var eventsText: ArrayBuffer[String] = null
    var manufacturerEvent: ManufacturerEvent = null
    var textPlaceHolder:String = null
    val manufacturer = new Manufacturer
    val manufacturerGenerator = new ManufacturerGenerator

    outputFileHandler = new FileHandler(new File(config.filePath, s"manufacturer_$threadName.data")
      .toString, config.fileRollSize)
    eventsText  = new ArrayBuffer[String](config.flushBatch)

    try {
      outputFileHandler.openFile()

      (eventsStartRange to eventsEndRange).foreach { eventCount =>
        batchCount += 1
        val mn = manufacturer.gen
        var combinations = Array[ManufacturerKey]()
        // generate manufacturer combinations
        1 to utils.randInt(config.minManufacturerCombinations, config.maxManufacturerCombinations) foreach { _ =>
          combinations = combinations :+ ManufacturerKey(mn, manufacturerGenerator.manufacturerPartNumber,
            manufacturerGenerator.categoryName)
        }
        combinations.distinct.foreach { m =>
          var master = true
          1 to utils.randInt(config.minEntriesPerManufacturer, config.maxEntriesPerManufacturer) foreach { _ =>
            if (master) {
              master = false
              // generate the master document for this manufacturer
              textPlaceHolder = formatEventToString(ManufacturerEvent(
                m.name,
                m.partNum,
                m.category,
                "PART",
                s"${m.name}|${m.partNum}",
                "MASTER",
                s"${m.name}|${m.partNum}",
                "null"
              ), config.outputFormat)
              eventsText += textPlaceHolder
              sizeCounter.getAndAdd(textPlaceHolder.getBytes.length)
              // increment universal record counter
              counter.getAndIncrement
              if (batchCount == config.flushBatch || batchCount == totalEvents) {
                outputFileHandler.publishBuffered(eventsText)
                eventsText.clear()
                batchCount = 0
              }
            }
            else {
              textPlaceHolder = formatEventToString(ManufacturerEvent(
                m.name,
                "null",
                "null",
                "PART",
                s"${m.name.toLowerCase}|${m.partNum.toLowerCase}",
                "DOCUMENT",
                s"${m.name.toLowerCase}|${manufacturerGenerator.randomString(8)}",
                "null"
              ), config.outputFormat)
              eventsText += textPlaceHolder
              sizeCounter.getAndAdd(textPlaceHolder.getBytes.length)
              // increment universal record counter
              counter.getAndIncrement
              if (batchCount == config.flushBatch || batchCount == totalEvents) {
                outputFileHandler.publishBuffered(eventsText)
                eventsText.clear()
                batchCount = 0
              }
            }
          }
        }
      }
      logger.debug(s"Events generated by $threadName is: $totalEvents from ($eventsStartRange) to ($eventsEndRange)")
    } catch {
      case e: Exception => logger.error("Error:: {}", e)
    }
    finally {
      outputFileHandler.close()
    }
  }
}
